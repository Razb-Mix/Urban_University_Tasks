# Задача "Многопроцессное считывание":
# Необходимо считать информацию из нескольких файлов одновременно, используя многопроцессный подход.
# Выполнение:
from datetime import datetime
from multiprocessing import Pool

# Создайте функцию read_info(name), где name - название файла. Функция должна:
def read_info(name: str):
    all_data: list = [] # Создавать локальный список all_data.
    with open(name, 'r', encoding='utf-8') as file: # Открывать файл name для чтения.
        for line in file: # Считывать информацию построчно (readline), пока считанная строка не окажется пустой.
            all_data.append(line) # Во время считывания добавлять каждую строку в список all_data.

filenames = [f'./file {number}.txt' for number in range(1, 5)] # Создайте список названий файлов из файлов архива.

# Для избежания некорректного вывода запускайте линейный вызов и многопроцессный по отдельности,
# предварительно закомментировав другой.

# Линейный вызов
# Вызовите функцию read_info для каждого файла по очереди (линейно)
# start_at = datetime.now()
# result = list(map(read_info, filenames)) # Вызовите функцию read_info для каждого файла по очереди (линейно)
# end_at = datetime.now()
# print(end_at - start_at, "(линейный)") # измерьте время выполнения и выведите его в консоль.

# Многопроцессный
# Вызовите функцию read_info для каждого файла, используя многопроцессный подход: контекстный менеджер with и объект Pool.
if __name__ == '__main__':
    start_at = datetime.now()
    with Pool() as p:
        # Для вызова функции используйте метод map, передав в него функцию read_info и список названий файлов.
        p.map(read_info, filenames)

    end_at = datetime.now()
    print(end_at - start_at, "(многопроцессный)")  # измерьте время выполнения и выведите его в консоль.